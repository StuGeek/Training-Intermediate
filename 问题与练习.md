# 问题与练习

### Part 1

#### Set 1

1、
+ 问题：Does the bug always move to a new location? Explain.
+ 回答：不会，只有当单元格存在且单元格为空或有花时，虫子才会移动到新位置，如果有石头，那么虫子不会移动到新位置。
  + 当单元格存在虫子才会移动，否则不会移动：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 98~99
    if (!gr.isValid(next))
        return false;
    ```
  + 如果单元格是空的或单元格中有花时，虫子才会移动：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 101
    return (neighbor == null) || (neighbor instanceof Flower);
    ```

2、
+ 问题：In which direction does the bug move?
+ 回答：向头朝向的方向往前移动。
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 76~79
    Location loc = getLocation();
    Location next = loc.getAdjacentLocation(getDirection());
    if (gr.isValid(next))
        moveTo(next);
    ```

3、
+ 问题：What does the bug do if it does not move?
+ 回答：它会向右旋转45°改变方向，然后继续尝试移动。
  + 当不能移动时，虫子进行转向：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 51~57
    public void act()
    {
        if (canMove())
            move();
        else
            turn();
    }
    ```
  + 转向是往当前朝向的右侧旋转45°：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 62~65
    public void turn()
    {
        setDirection(getDirection() + Location.HALF_RIGHT);
    }

    // @file: info/gridworld/grid/Location.java
    // @line: 48
    public static final int HALF_RIGHT = 45;
    ```

4、
+ 问题：What does a bug leave behind when it moves?
+ 回答：会在旧的位置留下一朵和其颜色一样的花。
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 82~83
    Flower flower = new Flower(getColor());
    flower.putSelfInGrid(gr, loc);
    ```

5、
+ 问题：What happens when the bug is at an edge of the grid? (Consider whether the bug is facing the edge as well as whether the bug is facing some other direction when answering this question.)
+ 回答：如果是在BoundedGrid中，当虫子朝向网格边缘时，它会右转45°，直到不朝向网格边缘且可以移动，如果是在UnBoundedGrid中，如果前方的单元格为空或者只有花时，虫子会继续向前移动至下一个网格，并在旧的位置留下一朵和其颜色一样的花，消失在当前视野中，需要拖动滚动条才能看到虫子位置。
  + 在BoundedGrid中，判断单元格是否存在的条件是不超出边界，而在UnBoundedGrid中，判断单元格是否存在的条件一直为真：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 60~64
    public boolean isValid(Location loc)
    {
        return 0 <= loc.getRow() && loc.getRow() < getNumRows()
                && 0 <= loc.getCol() && loc.getCol() < getNumCols();
    }

    // @file: info/gridworld/grid/UnboundedGrid.java
    // @line: 53~56
    public boolean isValid(Location loc)
    {
        return true;
    }

    ```
  + 那么在虫子的判断是否可以移动的方法中，如果有边界，那么在BoundedGrid中不能移动，在UnBoundedGrid中如果前面的单元格为空或者只有花，可以移动：
    ```java
    // @file: info/gridworld//actor/Bug.java
    // @line: 96~101
    Location loc = getLocation();
    Location next = loc.getAdjacentLocation(getDirection());
    if (!gr.isValid(next))
        return false;
    Actor neighbor = gr.get(next);
    return (neighbor == null) || (neighbor instanceof Flower);
    ```
  + 在BoundedGrid中不能移动就会向右转向45°，在UnBoundedGrid中可以移动则会移动并在原位置留下一朵花：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 53~56
    if (canMove())
        move();
    else
        turn();

    // @file: info/gridworld/actor/Bug.java
    // @line: 82~83
    Flower flower = new Flower(getColor());
    flower.putSelfInGrid(gr, loc);
    ```

6、
+ 问题：What happens when a bug has a rock in the location immediately in front of it?
+ 回答：它会向右转45°。
  + 有石头单元格是不能移动的状态：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 101
    return (neighbor == null) || (neighbor instanceof Flower);
    ```
  + 当虫子前面有石头时，虫子处在不能向前移动的状态，所以会向右转向45°角度：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 51~57
    public void act()
    {
        if (canMove())
            move();
        else
            turn();
    }
    ```

7、
+ 问题：Does a flower move?
+ 回答：不会。
  + 花的行为函数中只有关于颜色的设置
    ```java
    // @file: info/gridworld/actor/Flower.java
    // @line: 54~62
    public void act()
    {
        Color c = getColor();
        int red = (int) (c.getRed() * (1 - DARKENING_FACTOR));
        int green = (int) (c.getGreen() * (1 - DARKENING_FACTOR));
        int blue = (int) (c.getBlue() * (1 - DARKENING_FACTOR));

        setColor(new Color(red, green, blue));
    }
    ```

8、
+ 问题：What behavior does a flower have?
+ 回答：花的颜色会随着时间变暗，直到变成黑色。
  + 使用`DARKENING_FACTOR`使花的颜色随时间逐渐变暗
    ```java
    // @file: info/gridworld/actor/Flower.java
    // @line: 54~62
    public void act()
    {
        Color c = getColor();
        int red = (int) (c.getRed() * (1 - DARKENING_FACTOR));
        int green = (int) (c.getGreen() * (1 - DARKENING_FACTOR));
        int blue = (int) (c.getBlue() * (1 - DARKENING_FACTOR));

        setColor(new Color(red, green, blue));
    }
    ```

9、
+ 问题：Does a rock move or have any other behavior?
+ 回答：石头不会动，也没有其它行为。
  + 石头的行为函数没有任何动作：
    ```java
    // @file: info/gridworld/actor/Rock.java
    // @line: 54~56
    public void act()
    {
    }
    ```

10、
+ 问题：Can more than one actor (bug, flower, rock) be in the same location in the grid at the same time?
+ 回答：不行。
  + 如果放置新角色的单元格中本来有其它角色，那么这个角色先会被移除走
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 170~174
    Actor other = grid.get(newLocation);
    if (other != null)
        other.removeSelfFromGrid();
    location = newLocation;
    grid.put(location, this);
    ```

#### By clicking on a cell containing a bug, flower, or rock, do the following.

1、
+ 问题：Test the setDirection method with the following inputs and complete the table, giving the compass direction each input represents.
+ 回答：

    |Degrees|Compass Direction|
    |---|---|
    |0|North|
    |45|NorthEast|
    |90|East|
    |135|SouthEast|
    |180|South|
    |225|SouthWest|
    |270|West|
    |315|NorthWest|
    |360|North|

    ```java
    // @file: info/gridworld/grid/Location.java
    // @line: 65~93
    public static final int NORTH = 0;
    public static final int NORTHEAST = 45;
    public static final int EAST = 90;
    public static final int SOUTHEAST = 135;
    public static final int SOUTH = 180;
    public static final int SOUTHWEST = 225;
    public static final int WEST = 270;
    public static final int NORTHWEST = 315;
    ```

2、    
+ 问题：Move a bug to a different location using the moveTo method. In which directions can you move it? How far can you move it? What happens if you try to move the bug outside the grid?
+ 回答：可以将虫子移动到网格内的任何无论方向、无论距离的有效位置，并取代原来位置中角色。当尝试将虫子移出网格时，会引发IllegalArgumentException异常。
  + 如果要移动到的位置是不存在的位置，比如网格外之类的位置去，会抛出异常，并提示位置不是有效：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 163~165
    if (!grid.isValid(newLocation))
        throw new IllegalArgumentException("Location " + newLocation
                + " is not valid.");
    ```
  + 移动到的位置是有效的位置，那么新角色会被放到单元格中，并移除走之前的角色：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 170~174
    Actor other = grid.get(newLocation);
    if (other != null)
        other.removeSelfFromGrid();
    location = newLocation;
    grid.put(location, this);
    ```

3、
+ 问题：Change the color of a bug, a flower, and a rock. Which method did you use?
+ 回答：setColor方法。
  + 在Bug类、Flower类、Rock类中，设置颜色的方法都是setColor：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 45
    setColor(bugColor);

    // @file: info/gridworld/actor/Flower.java
    // @line: 61
    setColor(new Color(red, green, blue));

    // @file: info/gridworld/actor/Rock.java
    // @line: 47
    setColor(rockColor);
    ```

4、
+ 问题：Move a rock on top of a bug and then move the rock again. What happened to the bug?
+ 回答：虫子会消失了。
  + 将新角色放进原本有旧角色的单元格中时，旧角色会被直接移除：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 170~172
    Actor other = grid.get(newLocation);
    if (other != null)
        other.removeSelfFromGrid();
    ```

### Part 2

#### Set 2

1、
+ 问题：What is the role of the instance variable sideLength?
+ 回答：sideLength表示BoxBug在Box围成的矩形框的一侧长度。
  + 在BoxBug的行为方法act()中，如果走过的步数小于sideLength那么继续走，否则向右转弯90°，即一个直角，这样形成矩形，且步数清零，那么在矩形一侧走过的全部步数即一侧长度就是sideLength：
    ```java
    // @file: BoxBug.java
    // @line: 45~55
    if (steps < sideLength && canMove())
    {
        move();
        steps++;
    }
    else
    {
        turn();
        turn();
        steps = 0;
    }
    ```

2、
+ 问题：What is the role of the instance variable steps?
+ 回答：steps表示BoxBug在其Box围成的矩形框的一侧已经走的步数。
  + 在BoxBug的行为方法act()中，如果走过的步数小于sideLength那么继续走，否则向右转弯90°，即一个直角，这样形成矩形，且步数清零，那么在矩形一侧当前已经走过的步数就是sideLength：
    ```java
    // @file: BoxBug.java
    // @line: 45~55
    if (steps < sideLength && canMove())
    {
        move();
        steps++;
    }
    else
    {
        turn();
        turn();
        steps = 0;
    }
    ```

3、
+ 问题：Why is the turn method called twice when steps becomes equal to sideLength?
+ 回答：因为BoxBug每次要走矩形，那么转弯时每次要转90°才能形成直角，一次调用turn方法只能转45°，所以要调用turn方法两次。
  + 每次turn()转向是往当前朝向的右侧旋转45°：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 62~65
    public void turn()
    {
        setDirection(getDirection() + Location.HALF_RIGHT);
    }

    // @file: info/gridworld/grid/Location.java
    // @line: 48
    public static final int HALF_RIGHT = 45;
    ```

4、
+ 问题：Why can the move method be called in the BoxBug class when there is no move method in the BoxBug code?
+ 回答：因为BoxBug类继承自Bug类，在Bug类中move方法是公共方法，BoxBug类作为Bug类的子类继承了move方法，所以可以被调用。
  + BoxBug类继承基类Bug：
    ```java
    // @file: BoxBug.java
    // @line: 25
    public class BoxBug extends Bug
    ```
  + Bug类中有move()方法，可以被子类继承：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 71
    public void move()
    ```

5、
+ 问题：After a BoxBug is constructed, will the size of its square pattern always be the same? Why or why not?
+ 回答：构建了BoxBug之后，它的sideLength就已经确定，矩形框的边长已确定，不能被更改。
  + 在BoxBug类中，sideLength是私有类型成员变量，且没有提供set方法供外部更改：
    ```java
    // @file: BoxBug.java
    // @line: 28
    private int sideLength;
    ```

6、
+ 问题：Can the path a BoxBug travels ever change? Why or why not?
+ 回答：可以，如果BoxBug在前进道路上碰到石头或边界时，BoxBug就会改变方向并开始新的路径。
  + 在BoxBug的行为方法act()中，如果前进道路上碰到石头或边界时，那么canMove()条件为false不能移动，向右转弯90°，再继续移动：
    ```java
    // @file: BoxBug.java
    // @line: 45~55
    if (steps < sideLength && canMove())
    {
        move();
        steps++;
    }
    else
    {
        turn();
        turn();
        steps = 0;
    }
    ```

7、
+ 问题：When will the value of steps be zero?
+ 回答：当刚刚构建BoxBug时，steps为0，当steps等于sideLength时，steps也会变成0，或者BoxBug碰到石头或边界要转换方向时，steps会变为0。
  + 当刚刚构建BoxBug时，steps为0：
    ```java
    // @file: BoxBug.java
    // @line: 34~38
    public BoxBug(int length)
    {
        steps = 0;
        sideLength = length;
    }
    ```
  + 当BoxBug碰到石头或边界不能移动后要转换方向时，steps会变为0：
    ```java
    // @file: BoxBug.java
    // @line: 45~55
    if (steps < sideLength && canMove())
    {
        move();
        steps++;
    }
    else
    {
        turn();
        turn();
        steps = 0;
    }
    ```

### Part 3

#### Set 3

Assume the following statements when answering the following questions.

```
Location loc1 = new Location(4, 3);
Location loc2 = new Location(3, 4);
```

1、
+ 问题：How would you access the row value for loc1?
+ 回答：使用loc1.getRow()语句。
  + loc1是Location类的实例，在Location类中，获取行值的方法为：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 110~113
    public int getRow()
    {
        return row;
    }
    ```

2、
+ 问题：What is the value of b after the following statement is executed?
  ```
  boolean b = loc1.equals(loc2);
  ```
+ 回答：false。
  + Location类中的equals方法只有当两个实例的行和列值都相等时，才返回true，否则返回false，而loc1和loc2的行与列值不相等：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 211
    return getRow() == otherLoc.getRow() && getCol() == otherLoc.getCol();
    ```

3、
+ 问题：What is the value of loc3 after the following statement is executed?
  ```
  Location loc3 = loc2.getAdjacentLocation(Location.SOUTH);
  ```
+ 回答：(4, 4)。
  + 当获取loc2朝南方向的相邻位置时，这个方法会使loc2的行值3加1变成4，列值不变仍是4，这样就是位置(4, 4)：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 138
    int dc = 0;

    // @file: info/gridworld/grid/Loction.java
    // @line: 147~148
    else if (adjustedDirection == SOUTH)
        dr = 1;

    // @file: info/gridworld/grid/Loction.java
    // @line: 168
    return new Location(getRow() + dr, getCol() + dc);
    ```

4、
+ 问题：What is the value of dir after the following statement is executed?
  ```    
  int dir = loc1.getDirectionToward(new Location(6, 5));
  ```
+ 回答：135。
  + 在getDirectionToward方法中，首先获取参数和loc1的行和列的差值：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 180~181
    int dx = target.getCol() - getCol();
    int dy = target.getRow() - getRow();
    ```
    dx为2，dy为2。
  + 然后获取方位角，返回-dy和dx的反正切，并转化成角：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 183
    int angle = (int) Math.toDegrees(Math.atan2(-dy, dx));
    ```
    计算得到angel为135。
  + 最后将angel转化成罗盘角度，并四舍五入成45°的最接近倍数：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 187~194
    int compassAngle = RIGHT - angle;
    compassAngle += HALF_RIGHT / 2;
    if (compassAngle < 0)
        compassAngle += FULL_CIRCLE;
    return (compassAngle / HALF_RIGHT) * HALF_RIGHT;
    ```
    返回值为135。

5、
+ 问题：How does the getAdjacentLocation method know which adjacent location to return?
+ 回答：getAdjacentLocation方法中的参数direction指示要查找的相邻位置的方向。它返回指南针方向上最接近参数direction方向的相邻位置。
  + getAdjacentLocation方法的参数为direction：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 130
    public Location getAdjacentLocation(int direction)
    ```
  + 参数direction在方法中会首先转化成相邻方向变量adjustedDirection，最后根据相邻方向变量的值来选择不同的相邻位置：
    ```java
    // @file: info/gridworld/grid/Loction.java
    // @line: 133~137
    int adjustedDirection = (direction + HALF_RIGHT / 2) % FULL_CIRCLE;
    if (adjustedDirection < 0)
        adjustedDirection += FULL_CIRCLE;

    adjustedDirection = (adjustedDirection / HALF_RIGHT) * HALF_RIGHT;

    // @file: info/gridworld/grid/Loction.java
    // @line: 168
    return new Location(getRow() + dr, getCol() + dc);
    ```

#### Set 4

1、
+ 问题：How can you obtain a count of the objects in a grid? How can you obtain a count of the empty locations in a bounded grid?
+ 回答：使用BoundGrid的方法getOccupiedLocations().size()就可以找到grid中被占用的位置个数，也就是对象数。然后使用Grid的getNumRows()方法的返回值*Grid的getNumCols()方法的返回值，得到grid的总位置数，再用总位置数减去之前getOccupiedLocations().size()方法得到的被占用的位置数，就可以得到bound grid中的空位置数。
  + 在BoundGrid的getOccupiedLocations()方法中，通过遍历行和列，获取有对象的网格，加入ArrayList中，使用size()方法获取这个ArrayList的大小，就可以获得grid中被占用的位置个数：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 71~80
    for (int r = 0; r < getNumRows(); r++)
    {
        for (int c = 0; c < getNumCols(); c++)
        {
            Location loc = new Location(r, c);
            if (get(loc) != null)
                theLocations.add(loc);
        }
    }
    ```
  + 然后再使用getNumRows() * getNumCols()获取总位置数，减去getOccupiedLocations().size()就可以得到空位置数：
    ```java
    getNumRows() * getNumCols() - getOccupiedLocations().size()
    ```

2、
+ 问题：How can you check if location (10,10) is in a grid?
+ 回答：使用Grid的方法isValid(new Location(10,10))，如果返回值为true，那么说明位置(10,10)在grid中。
  + 在BoundGrid的isValid()方法中，如果获取位置的行小于0或大于等于Grid的行数，或者列小于0或大于等于Grid的列数，那么返回false，否则返回true：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 60~64
    public boolean isValid(Location loc)
    {
        return 0 <= loc.getRow() && loc.getRow() < getNumRows()
                && 0 <= loc.getCol() && loc.getCol() < getNumCols();
    }
    ```

3、
+ 问题：Grid contains method declarations, but no code is supplied in the methods. Why? Where can you find the implementations of these methods?
+ 回答：因为Grid是一个接口，里面声明的方法在不一定要接口类中实现，而是由AbstractGrid这个类继承并实现其中方法，以及AbstractGrid子类BoundedGrid、UnboundedGrid等重写实现。
  + 接口Grid可以被其它子类继承实现其中的方法：
    ```java
    // @file: info/gridworld/grid/Grid.java
    // @line: 29
    public interface Grid<E>
    ```
  + AbstractGrid抽象类继承Grid接口，并实现其中方法：
    ```java
    // @file: info/gridworld/grid/AbstractGrid.java
    // @line: 26
    public abstract class AbstractGrid<E> implements Grid<E>
    ```
  + 子类BoundedGrid、UnboundedGrid都继承了AbstractGrid类并重写覆盖其中的方法：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 29
    public class BoundedGrid<E> extends AbstractGrid<E>

    // @file: info/gridworld/grid/UnboundedGrid.java
    // @line: 31
    public class UnboundedGrid<E> extends AbstractGrid<E>
    ```

4、
+ 问题：All methods that return multiple objects return them in an ArrayList. Do you think it would be a better design to return the objects in an array? Explain your answer.
+ 回答：就实现这些方法而言，ArrayList不需要用户在填充之前调整大小，而数组需要。由于BoundedGrid不记录Grid中对象的数量，因此必须首先计算位置被占用的单元格数量以调整数组的大小，然后查找和存储Grid中每个被占用位置。所以使用ArrayList更好。
  + 比如在BoundGrid的getOccupiedLocations()方法中，通过遍历行和列，获取有对象的网格，加入ArrayList中，如果使用的是数组，在没有记录数组最后一个元素下标的情况下，临时向数组中加入元素就会显得比较麻烦，而且使用size()方法就可以获取这个数组的大小，如果使用的是数组的话，确定这个数组的大小也比较麻烦：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 71~80
    for (int r = 0; r < getNumRows(); r++)
    {
        for (int c = 0; c < getNumCols(); c++)
        {
            Location loc = new Location(r, c);
            if (get(loc) != null)
                theLocations.add(loc);
        }
    }
    ```

#### Set 5

1、
+ 问题：Name three properties of every actor.
+ 回答：color颜色，direction方向，location位置。
  + 类Actor中的成员变量属性有：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 31~34
    private Grid<Actor> grid;
    private Location location;
    private int direction;
    private Color color;
    ```

2、
+ 问题：When an actor is constructed, what is its direction and color?
+ 回答：初始化颜色为蓝色，初始化方向为North。
  + 在Actor的默认构造函数中，颜色初始化为蓝色，方向初始化为北边：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 39~45
    public Actor()
    {
        color = Color.BLUE;
        direction = Location.NORTH;
        grid = null;
        location = null;
    }
    ```

3、
+ 问题：Why do you think that the Actor class was created as a class instead of an interface?
+ 回答：因为一个Actor有行为和状态，状态可能不断变化，接口只能有`public static final`类型的不能改变的变量，也不能实现方法。
  + 在类中定义Actor的成员变量，就可以随状态改变进行更改：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 31~34
    private Grid<Actor> grid;
    private Location location;
    private int direction;
    private Color color;
    ```

4、
+ 问题：Can an actor put itself into a grid twice without first removing itself? 
+ 回答：不能，在BugRunner中，运行时会抛出IllegalStateException异常。
  + 当actor尝试对同一个位置调用两次putSelfInGrid方法时，第二次会先调用removeSelfFromGrid方法：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 121~123
    Actor actor = gr.get(loc);
    if (actor != null)
        actor.removeSelfFromGrid();
    ```
  + 在removeSelfFromGrid方法中，会将这个对象从grid中移除，并将grid和location置为null：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 143~145
    grid.remove(location);
    grid = null;
    location = null;
    ```
  + 此时再回到了putSelfInGrid方法中，会调用put方法尝试将这个放入grid，但此时这个actor的loction已经被之前置为null，所以会抛出IllegalStateException异常：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 124
    gr.put(loc, this);

    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 95~97
    if (!isValid(loc))
        throw new IllegalArgumentException("Location " + loc
                + " is not valid");
    ```

+ 问题：Can an actor remove itself from a grid twice?
+ 回答：不能，在BugRunner中，运行时会抛出IllegalStateException异常。
  + 当actor尝试对同一个位置调用两次removeSelfFromGrid方法，第二次会调用removeSelfFromGrid方法时，因为第一次已经将grid置为null，所以会抛出IllegalStateException异常：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 135~137
    if (grid == null)
        throw new IllegalStateException(
                "This actor is not contained in a grid.");
    ```

+ 问题：Can an actor be placed into a grid, remove itself, and then put itself back?
+ 回答：可以，在运行时无错误。
  + 当actor尝试对同一个位置先调用putSelfInGrid方法，再调用removeSelfFromGrid方法时，因为第一次已经设置了grid和location的值，所以可以正常移除，不会抛出异常：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 135~141
    if (grid == null)
        throw new IllegalStateException(
                "This actor is not contained in a grid.");
    if (grid.get(location) != this)
        throw new IllegalStateException(
                "The grid contains a different actor at location "
                        + location + ".");
    ```

5、
+ 问题：How can an actor turn 90 degrees to the right?
+ 回答：可以使用语句setDirection(getDirection() + Location.RIGHT)，在BugRunner中运行有效。
  + 在actor的setDirection方法中，可以设置actor朝向一个新的方向，可以通过getDirection()获取当前方向，在加上Location.RIGHT就是向右转向90°：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 80~85
    public void setDirection(int newDirection)
    {
        direction = newDirection % Location.FULL_CIRCLE;
        if (direction < 0)
            direction += Location.FULL_CIRCLE;
    }
    ```

#### Set 6

1、
+ 问题：Which statement(s) in the canMove method ensures that a bug does not try to move out of its grid?
+ 回答：
  ```java
  // @file: info/gridworld//actor/Bug.java
  // @line: 98~99
  if (!gr.isValid(next))
      return false;
  ```
  + 使用Grid的isValid方法，可以判断一个虫子仍然处在grid内，保证其不会越出去外界：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 60~64
    public boolean isValid(Location loc)
    {
        return 0 <= loc.getRow() && loc.getRow() < getNumRows()
                && 0 <= loc.getCol() && loc.getCol() < getNumCols();
    }
    ```

2、
+ 问题：Which statement(s) in the canMove method determines that a bug will not walk into a rock?
+ 回答：
  ```java
  // @file: info/gridworld/actor/Bug.java
  // @line: 100~101
  Actor neighbor = gr.get(next);
  return (neighbor == null) || (neighbor instanceof Flower);
  ```
  + 只有相邻网格中没有元素或为花时才会返回true，否则返回false，比如是石头时。

3、
+ 问题：Which methods of the Grid interface are invoked by the canMove method and why?
+ 回答：isValid方法和get方法，isValid方法是为了确保下一个位置是Grid中的有效位置，可以移动，get方法是为了查看这个位置中的对象并确保这个位置为空或者处在这个位置的对象可替换，从而可以使bug放到这个位置。
  + 在canMove方法中，有Grid的isValid方法和get方法被调用：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 98~100
    if (!gr.isValid(next))
        return false;
    Actor neighbor = gr.get(next);
    }
    ```

4、
+ 问题：Which method of the Location class is invoked by the canMove method and why?
+ 回答：getAdjacentLocation方法，这个方法的参数为虫子的当前方向并由bug调用，从而可以找到下一个可以移动的位置。
  + 在canMove方法中，有Location的getAdjacentLocation方法被调用：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 97
    Location next = loc.getAdjacentLocation(getDirection());
    }
    ```

5、
+ 问题：Which methods inherited from the Actor class are invoked in the canMove method?
+ 回答：getLocation方法、getDirection方法、getGrid方法。
  + 在canMove方法中，有继承于Actor类的getLocation、getDirection、getGrid方法方法被调用：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 93
    Grid<Actor> gr = getGrid();

    // @file: info/gridworld/actor/Bug.java
    // @line: 96~97
    Location loc = getLocation();
    Location next = loc.getAdjacentLocation(getDirection());
    }
    ```

6、
+ 问题：What happens in the move method when the location immediately in front of the bug is out of the grid?
+ 回答：bug会从Grid中直接消失。
  + 如果虫子前面的位置在grid外，那么为无效位置，虫子直接移除：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 78~81
    if (gr.isValid(next))
        moveTo(next);
    else
        removeSelfFromGrid();
    ```

7、
+ 问题：Is the variable loc needed in the move method, or could it be avoided by calling getLocation() multiple times?
+ 回答：需要，因为loc存储bug移动前的位置，不需要调用getLocation()方法就可以得到位置，减少了时间开销，更加地简洁。
  + 有loc这个变量的存在，就不需要频繁使用getLocation()方法，更加方便简洁：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 77
    Location next = loc.getAdjacentLocation(getDirection());

    // @file: info/gridworld/actor/Bug.java
    // @line: 83
    flower.putSelfInGrid(gr, loc);
    ```

8、
+ 问题：Why do you think the flowers that are dropped by a bug have the same color as the bug?
+ 回答：便于区分不同颜色的虫子的路径和留下的花朵。
  + 花朵的颜色会和虫子一样，可以以此区分不同虫子留下的路径：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 82~83
    Flower flower = new Flower(getColor());
    flower.putSelfInGrid(gr, loc);
    ```

9、
+ 问题：When a bug removes itself from the grid, will it place a flower into its previous location?
+ 回答：如果只是单独调用removeSelfFromGrid方法，那么不会留下花朵；如果是在Bug的move方法中调用removeSelfFromGrid方法移除虫子，那么会留下花朵。
  + 在Actor类的removeSelfFromGrid方法中，并没有与留下花朵有关的语句：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 133~146
    public void removeSelfFromGrid()
    {
        if (grid == null)
            throw new IllegalStateException(
                    "This actor is not contained in a grid.");
        if (grid.get(location) != this)
            throw new IllegalStateException(
                    "The grid contains a different actor at location "
                            + location + ".");

        grid.remove(location);
        grid = null;
        location = null;
    }
    ```
  + 在Bug类的move方法中，调用完removeSelfFromGrid方法移除虫子后，会留下花朵：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 80~83
    else
        removeSelfFromGrid();
    Flower flower = new Flower(getColor());
    flower.putSelfInGrid(gr, loc);
    ```

10、
+ 问题：Which statement(s) in the move method places the flower into the grid at the bug’s previous location?
+ 回答：
  ```java
  // @file: info/gridworld/actor/Bug.java
  // @line: 82~83
  Flower flower = new Flower(getColor());
  flower.putSelfInGrid(gr, loc);
  ```

11、
+ 问题：If a bug needs to turn 180 degrees, how many times should it call the turn method?
+ 回答：4次。
  + 转向是往当前朝向的右侧旋转45°：
    ```java
    // @file: info/gridworld/actor/Bug.java
    // @line: 62~65
    public void turn()
    {
        setDirection(getDirection() + Location.HALF_RIGHT);
    }

    // @file: info/gridworld/grid/Location.java
    // @line: 48
    public static final int HALF_RIGHT = 45;
    ```

### Part 4

#### Set 7

The source code for the Critter class is in the critters directory

1、
+ 问题：What methods are implemented in Critter?
+ 回答：act、getActors、processActors、getMoveLocations、selectMoveLocation、makeMove。
  + 动物Critter类中实现的方法有：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 38
    public void act()

    // @file: info/gridworld/actor/Critter.java
    // @line: 56
    public ArrayList<Actor> getActors()

    // @file: info/gridworld/actor/Critter.java
    // @line: 71
    public void processActors(ArrayList<Actor> actors)

    // @file: info/gridworld/actor/Critter.java
    // @line: 88
    public ArrayList<Location> getMoveLocations()

    // @file: info/gridworld/actor/Critter.java
    // @line: 104
    public Location selectMoveLocation(ArrayList<Location> locs)

    // @file: info/gridworld/actor/Critter.java
    // @line: 125
    public void makeMove(Location loc)
    ```

2、
+ 问题：What are the five basic actions common to all critters when they act?
+ 回答：getActors、processActors、getMoveLocations、selectMoveLocation、makeMove。
  + 在Critter的act方法中，有上面五个动作方法：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 42~46
    ArrayList<Actor> actors = getActors();
    processActors(actors);
    ArrayList<Location> moveLocs = getMoveLocations();
    Location loc = selectMoveLocation(moveLocs);
    makeMove(loc);
    ```

3、
+ 问题：Should subclasses of Critter override the getActors method? Explain.
+ 回答：如果子类要从和Critter不同的位置寻找actors，那么就需要重写方法。
  + 类Critter的子类CrabCritter只需要从前面、左前方和右前方获取Actor，所以重写了getActors方法：
    ```java
    // @file: CrabCritter.java
    // @line: 46~54
    ArrayList<Actor> actors = new ArrayList<Actor>();
    int[] dirs =
        { Location.AHEAD, Location.HALF_LEFT, Location.HALF_RIGHT };
    for (Location loc : getLocationsInDirections(dirs))
    {
        Actor a = getGrid().get(loc);
        if (a != null)
            actors.add(a);
    }
    ```

4、
+ 问题：Describe the way that a critter could process actors.
+ 回答：critter会移除actors中非石头和critter的actor元素。
  + 在Critter的processActors方法中，会把actors中不是石头和critter的元素给移除掉：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 73~77
    for (Actor a : actors)
    {
        if (!(a instanceof Rock) && !(a instanceof Critter))
            a.removeSelfFromGrid();
    }
    ```

5、
+ 问题：What three methods must be invoked to make a critter move? Explain each of these methods.
+ 回答：getMoveLocations, selectMoveLocation, makeMove。getMoveLocations返回critter相邻的所有的可移动到的空位置列表，selectMoveLocation随机地选择其中一个空位置并返回，如果没有空位置，那么返回critter的当前位置，makeMove将critter移动到指定位置处。
  + 在Critter的act方法中，getMoveLocations, selectMoveLocation, makeMove这三个方法使一个critter进行移动：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 44~46
    ArrayList<Location> moveLocs = getMoveLocations();
    Location loc = selectMoveLocation(moveLocs);
    makeMove(loc);
    ```
  + getMoveLocations返回critter相邻的所有的可移动到的空位置列表：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 90
    return getGrid().getEmptyAdjacentLocations(getLocation());
    ```
  + selectMoveLocation随机地选择其中一个空位置并返回，如果没有空位置，那么返回critter的当前位置：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 106~110
    int n = locs.size();
    if (n == 0)
        return getLocation();
    int r = (int) (Math.random() * n);
    return locs.get(r);
    ```
  + makeMove将critter移动到指定位置处：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 130
    moveTo(loc);
    ```

6、
+ 问题：Why is there no Critter constructor?
+ 回答：因为Critter继承了Actor类，Actor有默认构造函数，默认生成一个开始时朝向北的蓝色生物。
  + Actor类有一个生成一个开始时朝向北的蓝色生物的默认构造函数，被Critter类所继承了：
    ```java
    // @file: info/gridworld/actor/Actor.java
    // @line: 39~45
    public Actor()
    {
        color = Color.BLUE;
        direction = Location.NORTH;
        grid = null;
        location = null;
    }

    // @file: info/gridworld/actor/Critter.java
    // @line: 31
    public class Critter extends Actor
    ```

#### Set 8

The source code for the ChameleonCritter class is in the critters directory

1、
+ 问题：Why does act cause a ChameleonCritter to act differently from a Critter even though ChameleonCritter does not override act?
+ 回答：act方法调用getActors、processActors、getMoveLocations、selectMoveLocation和makeMove。而ChameleOnCriter类重写了其中的processActors和makeMove方法。所以，ChameleonCritter调用act方法行动时会和一般的Critter调用act方法行动的过程不同。
  + 在ChameleOnCriter类的processActors方法中，会随机选择一个相邻actor，获得actor的颜色，然后将自己的颜色更改为actor的颜色来进行Actor处理，而不是像普通Critter那样移除相邻的不是石头或critter的actor来进行Actor处理：
    ```java
    // @file: ChameleOnCriter.java
    // @line: 38~44
    int n = locs.size();
    if (n == 0)
        return getLocation();
    int r = (int) (Math.random() * n);
    return locs.get(r);
    ```
  + 在ChameleOnCriter类的makeMove中，它首先朝向下一个位置的方向，然后移动。ChameleOnCriter移动时不会改变方向。
    ```java
    // @file: ChameleOnCriter.java
    // @line: 52~53
    setDirection(getLocation().getDirectionToward(loc));
    super.makeMove(loc);
    ```

2、
+ 问题：Why does the makeMove method of ChameleonCritter call super.makeMove?
+ 回答：ChameleOnCriter的makeMove方法首先改变生物的方向，使其面对新的位置。然后调用父类Critter的makeMove方法实际移动到新位置。这样显示出来就是先改变方向再进行移动，而不是直接移动到新的位置，模拟小动物行为，直接使用父类中的方法也不用再次实现移动方法，代码结构清晰：
  ```java
  // @file: ChameleOnCriter.java
  // @line: 52~53
  setDirection(getLocation().getDirectionToward(loc));
  super.makeMove(loc);
  ```

3、
+ 问题：How would you make the ChameleonCritter drop flowers in its old location when it moves?
+ 回答：可以在makeMove方法中进行修改，这样就需要一个变量来跟踪ChameleonCritter的当前位置。当调用makeMove方法尝试进行移动时，只有当ChameleonCritter实际移动到新位置时，才将花放在原来的位置：
  ```java
  // @file: ChameleOnCriter.java
  // @line: 50~61
  public void makeMove(Location loc)
  {
      Location preLocation = getLocation();
      setDirection(getLocation().getDirectionToward(loc));
      super.makeMove(loc);
      // 当ChameleonCritter实际移动到新位置时，才将花放在原来的位置
      if(!loc.equals(preLocation))
      {
          Flower flower = new Flower(getColor());
          flower.putSelfInGrid(getGrid(), preLocation);
      } 
  }
  ```

4、
+ 问题：Why doesn’t ChameleonCritter override the getActors method?
+ 回答：因为ChameleonCritter处理相邻Actors列表与它的基类Critter相同。没有定义新的行为，所以它不需要重写这个方法：
  ```java
  // @file: info/gridworld/actor/Critter.java
  // @line: 58
  return getGrid().getNeighbors(getLocation());
  ```

5、
+ 问题：Which class contains the getLocation method?
+ 回答：Actor类包含getLocation方法，所有Actor子类都继承此方法：
  ```java
  // @file: info/gridworld/actor/Actor.java
  // @line: 102
  public Location getLocation()
  ```

6、
+ 问题：How can a Critter access its own grid?
+ 回答：Critter可以通过调用从Actor类继承的getGrid方法来访问它的grid：
  ```java
  // @file: info/gridworld/actor/Actor.java
  // @line: 92
  public Grid<Actor> getGrid()

  // @file: info/gridworld/actor/Critter.java
  // @line: 31
  public class Critter extends Actor
  ```

#### Set 9

The source code for the CrabCritter class is reproduced at the end of this part of GridWorld.

1、
+ 问题：Why doesn’t CrabCritter override the processActors method?
+ 回答：CrabCritter通过吃掉调用getActors时返回的所有相邻actor来处理其角色。这与它从基类Critter继承的processActors方法的行为相同，都是需要获取所有相邻的actor，不需要重写此方法：
  ```java
  // @file: info/gridworld/actor/Critter.java
  // @line: 73~77
  for (Actor a : actors)
  {
      if (!(a instanceof Rock) && !(a instanceof Critter))
          a.removeSelfFromGrid();
  }
  ```

2、
+ 问题：Describe the process a CrabCritter uses to find and eat other actors. Does it always eat all neighboring actors? Explain.
+ 回答：CrabCritter的getActors方法只查找与CrabCritter前方、右前方和左前方位置的相邻actor。调用processActors方法时，在这些位置找到的任何actor都将被吃掉。其他相邻的actor不会受到影响：
  ```java
  // @file: CrabCritter.java
  // @line: 46~54
  ArrayList<Actor> actors = new ArrayList<Actor>();
  int[] dirs =
      { Location.AHEAD, Location.HALF_LEFT, Location.HALF_RIGHT };
  for (Location loc : getLocationsInDirections(dirs))
  {
      Actor a = getGrid().get(loc);
      if (a != null)
          actors.add(a);
  }
  ```

3、
+ 问题：Why is the getLocationsInDirections method used in CrabCritter?
+ 回答：此方法的参数是一个方向数组。对于CrabCritter，这个数组包含了CrabCritter可能可以吃的相邻actor的方向。getLocationsInDirections方法使用该数组确定并返回该CrabCritter在数组参数给定方向上的有效相邻位置：
  ```java
  // @file: CrabCritter.java
  // @line: 107~112
  for (int d : directions)
  {
      Location neighborLoc = loc.getAdjacentLocation(getDirection() + d);
      if (gr.isValid(neighborLoc))
          locs.add(neighborLoc);
  }
  ```

4、
+ 问题：If a CrabCritter has location (3, 4) and faces south, what are the possible locations for actors that are returned by a call to the getActors method?
+ 回答：(4,3)，(4,4)，(4,5)。
  + 因为CrabCritter的getActors方法只查找与CrabCritter前方、右前方和左前方位置的相邻actor。此时CrabCritter的位置为(3, 4)，朝向南边，那么前方的位置为(4,4)，左前方的位置为(4,5)，右前方的位置为(4,3)：
  ```java
  // @file: CrabCritter.java
  // @line: 46~54
  ArrayList<Actor> actors = new ArrayList<Actor>();
  int[] dirs =
      { Location.AHEAD, Location.HALF_LEFT, Location.HALF_RIGHT };
  for (Location loc : getLocationsInDirections(dirs))
  {
      Actor a = getGrid().get(loc);
      if (a != null)
          actors.add(a);
  }
  ```

5、
+ 问题：What are the similarities and differences between the movements of a CrabCritter and a Critter?
+ 回答：
  + 相似之处：当Critter和CrabCritter移动时，它们都不会直接朝着面前的方向移动，而是从可能的移动位置列表中随机选择下一个位置：
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 90
    return getGrid().getEmptyAdjacentLocations(getLocation());

    // @file: CrabCritter.java
    // @line: 67~69
    for (Location loc : getLocationsInDirections(dirs))
        if (getGrid().get(loc) == null)
            locs.add(loc);
    }
    ```
  + 区别：CrabCritter只会向左或向右移动。Critter可能的移动位置是其八个相邻位置中的任意一个。当CrabCritter无法移动时，它会随机向右或向左转弯。当Critter不能移动时，它不会转弯。
    ```java
    // @file: info/gridworld/actor/Critter.java
    // @line: 90
    return getGrid().getEmptyAdjacentLocations(getLocation());

    // @file: CrabCritter.java
    // @line: 65~69
    int[] dirs =
            { Location.LEFT, Location.RIGHT };
    for (Location loc : getLocationsInDirections(dirs))
        if (getGrid().get(loc) == null)
            locs.add(loc);
    }

    // @file: info/gridworld/actor/Critter.java
    // @line: 127~130
    if (loc == null)
        removeSelfFromGrid();
    else
        moveTo(loc);
    
    // @file: CrabCritter.java
    // @line: 79~88
    if (loc.equals(getLocation()))
    {
        double r = Math.random();
        int angle;
        if (r < 0.5)
            angle = Location.LEFT;
        else
            angle = Location.RIGHT;
        setDirection(getDirection() + angle);
    }
    ```

6、
+ 问题：How does a CrabCritter determine when it turns instead of moving?
+ 回答：如果makeMove中的参数loc等于CrabCritter的当前位置，它将旋转而不是移动：
  ```java
  // @file: CrabCritter.java
  // @line: 79~88
  if (loc.equals(getLocation()))
  {
      double r = Math.random();
      int angle;
      if (r < 0.5)
          angle = Location.LEFT;
      else
          angle = Location.RIGHT;
      setDirection(getDirection() + angle);
  }
  ```

7、
+ 问题：Why don’t the CrabCritter objects eat each other?
+ 回答：CrabCritter从Critter类继承processActors方法。此方法仅移除非石头和非生物的角色。因为CrabCritter是Critter的子类，CrabCritter就也不会吃任何其他Critter：
  ```java
  // @file: info/gridworld/actor/Critter.java
  // @line: 75~76
  if (!(a instanceof Rock) && !(a instanceof Critter))
      a.removeSelfFromGrid();

  // @file: CrabCritter.java
  // @line: 32
  public class CrabCritter extends Critter
  ```

### Part5

#### Set 10

The source code for the AbstractGrid class is in Appendix D.

1、
+ 问题：Where is the isValid method specified? Which classes provide an implementation of this method?
+ 回答：isValid方法在Grid接口中指定。BoundedGrid和UnboundedGrid类实现此方法：
  ```java
  // @file: info/gridworld/grid/Grid.java
  // @line: 50
  boolean isValid(Location loc);

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 60~64
  public boolean isValid(Location loc)
  {
      return 0 <= loc.getRow() && loc.getRow() < getNumRows()
              && 0 <= loc.getCol() && loc.getCol() < getNumCols();
  }

  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 53~56
  public boolean isValid(Location loc)
  {
      return true;
  }
  ```

2、
+ 问题：Which AbstractGrid methods call the isValid method? Why don’t the other methods need to call it?
+ 回答：方法getValidAdjacentLocations调用isValid方法。方法GetEmptyAjacentLocations和GetOccuppiedAjacentLocations不直接调用isValid，而是通过调用getValidAdjacentLocations进行间接调用isValid。方法GetNeights不直接调用isValid。它调用GetOccuppiedAjacentLocations，间接调用GetValidAjacentLocations，最后间接调用isValid：
  ```java
  // @file: info/gridworld/grid/AbstractGrid.java
  // @line: 44~45
  if (isValid(neighborLoc))
      locs.add(neighborLoc);

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 54~58
  for (Location neighborLoc : getValidAdjacentLocations(loc))
  {
      if (get(neighborLoc) == null)
          locs.add(neighborLoc);
  }

  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 65~69
  for (Location neighborLoc : getValidAdjacentLocations(loc))
  {
      if (get(neighborLoc) != null)
          locs.add(neighborLoc);
  }

  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 31~32
  for (Location neighborLoc : getOccupiedAdjacentLocations(loc))
      neighbors.add(get(neighborLoc));
  ```

3、
+ 问题：Which methods of the Grid interface are called in the getNeighbors method? Which classes provide implementations of these methods?
+ 回答：方法getNeighbors调用Grid的方法get和getOccuppiedAjacentLocations。AbstractGrid类实现GetOccupiedAjacentLocations方法。get方法在BoundedGrid和UnboundedGrid类中实现：
  ```java
  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 31~32
  for (Location neighborLoc : getOccupiedAdjacentLocations(loc))
      neighbors.add(get(neighborLoc));
  
  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 62
  public ArrayList<Location> getOccupiedAdjacentLocations(Location loc)

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 85~91
  public E get(Location loc)
  {
      if (!isValid(loc))
          throw new IllegalArgumentException("Location " + loc
                  + " is not valid");
      return (E) occupantArray[loc.getRow()][loc.getCol()]; // unavoidable warning
  }

  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 66~71
  public E get(Location loc)
  {
      if (loc == null)
          throw new NullPointerException("loc == null");
      return occupantMap.get(loc);
  }
  ```

4、
+ 问题：Why must the get method, which returns an object of type E, be used in the getEmptyAdjacentLocations method when this method returns locations, not objects of type E?
+ 回答：get方法返回对存储在grid中给定位置的对象的引用，如果不存在对象，则返回null。getEmptyAjacentLocations调用get方法并测试结果是否为null。如果返回null，则该位置为空，并添加到列表中。调用get方法是测试给定位置是否为空或被占用的唯一方法。
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 85~91
  public E get(Location loc)
  {
      if (!isValid(loc))
          throw new IllegalArgumentException("Location " + loc
                  + " is not valid");
      return (E) occupantArray[loc.getRow()][loc.getCol()]; // unavoidable warning
  }

  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 66~71
  public E get(Location loc)
  {
      if (loc == null)
          throw new NullPointerException("loc == null");
      return occupantMap.get(loc);
  }
  ```

5、
+ 问题：What would be the effect of replacing the constant Location.HALF_RIGHT with Location.RIGHT in the two places where it occurs in the getValidAdjacentLocations method?
+ 回答：可能的有效相邻位置的数量将从8个减少到4个。有效的相邻位置为给定位置的北边、南边、东边和西边：
  ```java
  // @file: info/gridworld/grid/AbstractGrid.java
  // @line: 40~47
  int d = Location.NORTH;
  for (int i = 0; i < Location.FULL_CIRCLE / Location.RIGHT; i++)
  {
      Location neighborLoc = loc.getAdjacentLocation(d);
      if (isValid(neighborLoc))
          locs.add(neighborLoc);
      d = d + Location.RIGHT;
  }
  ```

#### Set 11

The source code for the BoundedGrid class is in Appendix D.

1、
+ 问题：What ensures that a grid has at least one valid location?
+ 回答：如果行数小于等于0或列数小于等于0，BoundedGrid的构造函数将抛出IllegalArgumentException异常：
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 39~46
  public BoundedGrid(int rows, int cols)
  {
      if (rows <= 0)
          throw new IllegalArgumentException("rows <= 0");
      if (cols <= 0)
          throw new IllegalArgumentException("cols <= 0");
      occupantArray = new Object[rows][cols];
  }
  ```

2、
+ 问题：How is the number of columns in the grid determined by the getNumCols method? What assumption about the grid makes this possible?
+ 回答：通过返回occupantArray[0].length的值，确定occupantArray数组第0行中的列数。构造函数确保每个BoundedGrid对象至少有一行和一列：
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 39~46
  return occupantArray[0].length;

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 39~46
  public BoundedGrid(int rows, int cols)
  {
      if (rows <= 0)
          throw new IllegalArgumentException("rows <= 0");
      if (cols <= 0)
          throw new IllegalArgumentException("cols <= 0");
      occupantArray = new Object[rows][cols];
  }
  ```

3、
+ 问题：What are the requirements for a Location to be valid in a BoundedGrid?
+ 回答：位置的行值必须大于等于0且小于BoundedGrid中的行数。位置的列值必须大于等于0且小于BoundedGrid中的列数：
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 60~64
  public boolean isValid(Location loc)
  {
      return 0 <= loc.getRow() && loc.getRow() < getNumRows()
              && 0 <= loc.getCol() && loc.getCol() < getNumCols();
  }
  ```

In the next four questions, let r = number of rows, c = number of columns, and n = number of occupied locations.

4、
+ 问题：What type is returned by the getOccupiedLocations method? What is the time complexity (Big-Oh) for this method?
+ 回答：getOccupiedLocations方法返回ArrayList\<Location\>类型的返回值。这个方法的时间复杂度是O(r * c)，因为每次必须访问BoundedGrid中的每个位置，以查看这个位置是否被占用，被占用的位置将添加到ArrayList的末尾，这个操作是O(1)，一共有r * c个位置，所以时间复杂度是O(r * c)：
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 66
  public ArrayList<Location> getOccupiedLocations()

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 71~80
  for (int r = 0; r < getNumRows(); r++)
  {
      for (int c = 0; c < getNumCols(); c++)
      {
          Location loc = new Location(r, c);
          if (get(loc) != null)
              theLocations.add(loc);
      }
  }
  ```

5、
+ 问题：What type is returned by the get method? What parameter is needed? What is the time complexity (Big-Oh) for this method?
+ 回答：get方法返回值的类型是存储在occupantArray中的任意类型E。get方法需要的参数是一个Location对象。这个方法的时间复杂度是O(1)，因为根据给定行列下标访问二维数组的特定位置，这个操作的时间复杂度是O(1)：
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 85
  public E get(Location loc)

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 90
  return (E) occupantArray[loc.getRow()][loc.getCol()]; // unavoidable warning
  ```

6、
+ 问题：What conditions may cause an exception to be thrown by the put method? What is the time complexity (Big-Oh) for this method?
+ 回答：如果要添加对象的位置是无效位置，即不在grid中，将引发抛出IllegalArgumentException。如果要添加对象为null，也会抛出NullPointerException异常。这个方法的时间复杂度为O(1)，因为根据给定行列下标赋值二维数组的特定位置，这个操作的时间复杂度是O(1)：
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 95~99
  if (!isValid(loc))
      throw new IllegalArgumentException("Location " + loc
              + " is not valid");
  if (obj == null)
      throw new NullPointerException("obj == null");

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 103
  occupantArray[loc.getRow()][loc.getCol()] = obj;
  ```

7、
+ 问题：What type is returned by the remove method? What happens when an attempt is made to remove an item from an empty location? What is the time complexity (Big-Oh) for this method?
+ 回答：remove方法返回值的类型是存储在occupantArray中的任意类型E。如果试图从空位置删除对象，则该位置中存储null，并返回null。在空位置调用Grid类的remove方法不会发生错误。这个方法的时间复杂度为O(1)，因为根据给定行列下标赋值二维数组的特定位置为null，这个操作的时间复杂度是O(1)：
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 107
  public E remove(Location loc)

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 115
  occupantArray[loc.getRow()][loc.getCol()] = null;
  ```

8、
+ 问题：Based on the answers to questions 4, 5, 6, and 7, would you consider this an efficient implementation? Justify your answer.
+ 回答：在问题4, 5, 6, 7中，时间复杂度最高的方法是getOccupiedLocations，为O(r * c)，其它方法的时间复杂度都为O(1)，实现基本还算有效率。而BoundedGrid不仅会在占用的位置存储元素，还会将空值存储在未占用的位置。如果使用Map，使这个有界网格只存储占用的位置元素，同时访问时间复杂度仍然为O(1)，这样的实现更有效率。
  ```java
  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 31
  private Object[][] occupantArray;

  // @file: info/gridworld/grid/BoundedGrid.java
  // @line: 31
  private Map<Location, E> occupantMap;
  ```

#### Set 12

The source code for the UnboundedGrid class is in Appendix D.

1、
+ 问题：Which method must the Location class implement so that an instance of HashMap can be used for the map? What would be required of the Location class if a TreeMap were used instead? Does Location satisfy these requirements?
+ 回答：Location类必须实现hashCode和equals方法。hashCode方法必须为两个调用equals方法返回为true的Location返回相同的值：
  ```java
  // @file: info/gridworld/grid/Location.java
  // @line: 218~221
  public int hashCode()
  {
      return getRow() * 3737 + getCol();
  }

  // @file: info/gridworld/grid/Location.java
  // @line: 205~212
  public boolean equals(Object other)
  {
      if (!(other instanceof Location))
          return false;

      Location otherLoc = (Location) other;
      return getRow() == otherLoc.getRow() && getCol() == otherLoc.getCol();
  }
  ```
  + Location类实现了Comparable接口。因此，必须要实现Comparable接口中的compareTo方法。compareTo方法应该为两个调用equals方法返回为true的Location返回0。TreeMap要求映射的键具有可比性。Location类满足所有这些要求：
    ```java
    // @file: info/gridworld/grid/Location.java
    // @line: 234~246
    public int compareTo(Object other)
    {
        Location otherLoc = (Location) other;
        if (getRow() < otherLoc.getRow())
            return -1;
        if (getRow() > otherLoc.getRow())
            return 1;
        if (getCol() < otherLoc.getCol())
            return -1;
        if (getCol() > otherLoc.getCol())
            return 1;
        return 0;
    }
    ```

2、
+ 问题：Why are the checks for null included in the get, put, and remove methods? Why are no such checks included in the corresponding methods for the BoundedGrid?
+ 回答：UnboundedGrid使用HashMap作为其数据结构来保存grid中的项。所有非空位置在UnboundedGrid中都有效。UnboundedGrid的isValid方法始终返回true；它不检查空位置。在映射对象中，null是键的合法值：
  ```java
  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 53~56
  public boolean isValid(Location loc)
  {
      return true;
  }
  ```
  + 在UnboundedGrid对象中，null不是有效位置。因此，UnboundedGrid方法get、put和remove必须检查Location参数，并在参数为null时抛出NullPointerException异常：
    ```java
    // @file: info/gridworld/grid/UnboundedGrid.java
    // @line: 68~69、75~76、84~58
    if (loc == null)
        throw new NullPointerException("loc == null");
    ```
  + 在使用Location参数访问BoundedGrid中的occupantArray时，将调用isValid方法。如果isValid方法中的Location参数为null，则在isValid方法中，使用loc.getRow()时候就会抛出NullPointerException异常：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 87~89、95~97、109~111
    if (!isValid(loc))
        throw new IllegalArgumentException("Location " + loc
                + " is not valid");

    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 60~64
    public boolean isValid(Location loc)
    {
        return 0 <= loc.getRow() && loc.getRow() < getNumRows()
                && 0 <= loc.getCol() && loc.getCol() < getNumCols();
    }
    ```
  + 如果编写的代码在调用get、put和remove方法之前没有调用isValid方法，那么在这些方法中使用loc.getRow()时候也会抛出NullPointerException异常：
    ```java
    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 90
    return (E) occupantArray[loc.getRow()][loc.getCol()];

    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 103
    occupantArray[loc.getRow()][loc.getCol()] = obj;

    // @file: info/gridworld/grid/BoundedGrid.java
    // @line: 115
    occupantArray[loc.getRow()][loc.getCol()] = null;
    ```

3、
+ 问题：What is the average time complexity (Big-Oh) for the three methods: get, put, and remove? What would it be if a TreeMap were used instead of a HashMap?
+ 回答：get、put和remove方法的平均时间复杂度为O(1)，因为都是直接通过键值访问相应位置：
  ```java
  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 90
  return occupantMap.get(loc);

  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 103
  return occupantMap.put(loc, obj);

  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 115
  return occupantMap.remove(loc);
  ```
  + 如果使用TreeMap而不是HashMap，因为TreeMap将其键存储在一个平衡的二叉搜索树中，则平均时间复杂度为O(logn)，其中n是grid中被占用的位置数。

4、
+ 问题：How would the behavior of this class differ, aside from time complexity, if a TreeMap were used instead of a HashMap?
+ 回答：如果使用的是HashMap，在getOccupiedLocations方法中获取keySet时，因为HashMap中的键根据使用键的哈希码和表的大小计算的索引放置在哈希表中。那么遍历键集时访问键的顺序取决于它在哈希表中的位置：
  ```java
  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 61~62
  for (Location loc : occupantMap.keySet())
      a.add(loc);
  ```
  + 如果使用的是TreeMap，那么大多数情况下，getOccupiedLocations方法将以不同的顺序返回被占用的位置，因为TreeMap将其键存储在一个平衡的二叉搜索树中，并以无序遍历的方式遍历该树。键集中的键将按位置的compareTo方法定义的升序行主顺序访问。

5、
+ 问题：Could a map implementation be used for a bounded grid? What advantage, if any, would the two-dimensional array implementation that is used by the BoundedGrid class have over a map implementation?
+ 回答：一个map实现可以用在BoundedGrid中。如果使用HashMap来实现BoundedGrid，那么只需要记录被占用的位置，则getOccupiedLocations方法的平均时间复杂度为O(n)，其中n是网格中的项目数，类似于UnboundedGrid中的实现：
  ```java
  // @file: info/gridworld/grid/UnboundedGrid.java
  // @line: 61~62
  for (Location loc : occupantMap.keySet())
      a.add(loc);
  ```
  + 如果BoundedGrid几乎已满，则map实现将使用更多内存，因为map存储项及其位置。二维数组仅存储项。通过组合每个项目的行和列索引来生成位置，可以节省内存。